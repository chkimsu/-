"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.combine = combine;
exports.combineByCode = combineByCode;
exports.combineByJong = combineByJong;
exports.combineByJung = combineByJung;
exports.combineHangul = combineHangul;
var _constant = require("./constant");
var _utils = require("./utils");
var _isCho = require("./isCho");
var _isJung = require("./isJung");
var _isJong = require("./isJong");
var _isHangul = require("./isHangul");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var fromCharCodeMemo = {};
function combineByCode() {
  var cho = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var jung = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var jong = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var hangulCode = _constant.HANGUL_START_CHARCODE + cho * _constant.CHO_PERIOD + jung * _constant.JONG_PERIOD + jong;
  if (!(0, _isHangul.isHangulByCode)(hangulCode)) {
    return "";
  }
  if (!fromCharCodeMemo[hangulCode]) {
    fromCharCodeMemo[hangulCode] = String.fromCharCode(hangulCode);
  }
  return fromCharCodeMemo[hangulCode];
}
function combine() {
  var cho = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
  var jung = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
  var jong = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
  var combineJung = combineByJung(jung);
  var combineJong = combineByJong(jong);
  var choIndex = _constant.CHO_HANGUL.indexOf(cho);
  var jungIndex = _constant.JUNG_HANGUL.indexOf(combineJung);
  var jongIndex = _constant.JONG_HANGUL.indexOf(combineJong);
  if (choIndex === -1 || jungIndex === -1 || jongIndex === -1) {
    return cho || combineJung || combineJong;
  }
  return combineByCode(choIndex, jungIndex, jongIndex);
}
function combineLoop(wordList) {
  var index = 0;
  var result = [];
  while (index < wordList.length) {
    var first = wordList[index++];
    var cho = (0, _isCho.isCho)(first) ? first : "";
    var jung = cho && (0, _isJung.isJung)(wordList[index]) ? wordList[index++] : "";

    // 초성 또는 중성 합쳐지지 않고, 종성 의미 X,
    if (!cho || !jung) {
      result.push(first);
      continue;
    }

    // 중성이 없으면 소용 X
    var subJung = _constant.JUNG_COMPLETE_HANGUL[combineByJung(jung + wordList[index])] ? wordList[index++] : "";

    // 다음 문자에 모음이 안오는 경우 (합쳐질 가능성 존재)
    var jong = (0, _isJong.isJong)(wordList[index]) && !(0, _isJung.isJung)(wordList[index + 1]) ? wordList[index++] : "";

    // 두 문자 모두 초성이면서 (이미 합쳐진 문자 X - ㅄ, ㄺ X)
    // 다음 문자에 모음이 안오는 경우 (합쳐질 가능성 존재)
    var subJong = _constant.JONG_COMPLETE_HANGUL[combineByJong(jong + wordList[index])] && !(0, _isJung.isJung)(wordList[index + 1]) ? wordList[index++] : "";
    result.push(combine(cho, jung + subJung, jong + subJong));
  }
  return result.join("");
}
function combineHangul() {
  var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
  var word = typeof str === "string" ? str.toString().split("") : str;

  // Group 형식일 때, [ ['ㄱㅏ'], 'ㄴㅏ', ['ㄷ', 'ㅏ'] ]
  var result = [];
  var _temp = [];
  for (var index = 0; index < word.length; index++) {
    var item = word[index];
    if (typeof item === "string") {
      _temp.push.apply(_temp, _toConsumableArray(item.toString().split("")));
    } else {
      result.push(combineLoop(_temp.splice(0)).concat(combineLoop(item.join("").split(""))));
    }
  }
  result.push(combineLoop(_temp));
  return result.join("");
}
var REVERSE_JUNG_COMPLETE = (0, _utils.reverseByObject)(_constant.JUNG_COMPLETE_HANGUL);
var REVERSE_JONG_COMPLETE = (0, _utils.reverseByObject)(_constant.JONG_COMPLETE_HANGUL);
function combineByJung(jung) {
  return REVERSE_JUNG_COMPLETE[jung] || jung;
}
function combineByJong(jong) {
  return REVERSE_JONG_COMPLETE[jong] || jong;
}