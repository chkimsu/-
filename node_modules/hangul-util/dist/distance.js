"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.correctByDistance = correctByDistance;
exports.getDistance = getDistance;
var _divide = require("./divide");
var _sortHangul = require("./sortHangul");
function minBy(x1, x2, x3) {
  return x1 > x2 ? x2 > x3 ? x3 : x2 : x3 > x1 ? x1 : x3;
}
var memo = {};

// levenshtein distance
function getDistance(first, second) {
  if (first === second) return 0;
  if (!first) return second.length;
  if (!second) return first.length;
  if (memo[first + '||' + second]) {
    return memo[first + '||' + second];
  }
  var getDistance = [[]];

  // 초기값 설정
  for (var j = 0; j <= second.length; j++) {
    getDistance[0][j] = j;
  }
  for (var i = 1; i <= first.length; i++) {
    getDistance[i] = [i];
    for (var _j = 1; _j <= second.length; _j++) {
      getDistance[i][_j] = minBy(getDistance[i - 1][_j] + 1, getDistance[i][_j - 1] + 1, getDistance[i - 1][_j - 1] + (first[i - 1] === second[_j - 1] ? 0 : 1));
    }
  }
  memo[first + '||' + second] = getDistance[first.length][second.length];
  return getDistance[first.length][second.length];
}
function correctByDistance(word, list, option) {
  var _option$distance, _option$maxSlice, _option$isSplit;
  var distance = (_option$distance = option === null || option === void 0 ? void 0 : option.distance) !== null && _option$distance !== void 0 ? _option$distance : Math.max(word.length / 2, 2);
  var maxSlice = (_option$maxSlice = option === null || option === void 0 ? void 0 : option.maxSlice) !== null && _option$maxSlice !== void 0 ? _option$maxSlice : 10;
  var isSplit = (_option$isSplit = option === null || option === void 0 ? void 0 : option.isSplit) !== null && _option$isSplit !== void 0 ? _option$isSplit : true;
  var minDist = [];
  var dividedWord = (0, _divide.divideHangul)(word, true).join("");
  for (var index = 0; index < list.length; index++) {
    var dist = isSplit ? getDistance(dividedWord, (0, _divide.divideHangul)(list[index], true).join("")) : getDistance(word, list[index]);
    if (dist <= distance) {
      minDist.push({
        dist: dist,
        word: list[index]
      });
    }
  }
  return (0, _sortHangul.sortByASC)(minDist, "dist").slice(0, maxSlice).map(function (item) {
    return item.word;
  });
}