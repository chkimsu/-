{"version":3,"file":"kor-to-number.module.js","sources":["../src/constants.ts","../src/index.ts"],"sourcesContent":["type MAP_TYPE = {\r\n  [key: string]: number;\r\n};\r\ntype ORDERED_MAP_TYPE = [string, number][];\r\nconst SINO_MAP_ONES: MAP_TYPE = {\r\n  일: 1,\r\n  이: 2,\r\n  삼: 3,\r\n  사: 4,\r\n  오: 5,\r\n  육: 6,\r\n  륙: 6,\r\n  칠: 7,\r\n  팔: 8,\r\n  구: 9,\r\n};\r\nconst SINO_MAP_SMALL: ORDERED_MAP_TYPE = [\r\n  [\"천\", 1000],\r\n  [\"백\", 100],\r\n  [\"십\", 10],\r\n];\r\nconst SINO_MAP_LARGE: ORDERED_MAP_TYPE = [\r\n  [\"양\", 1e28],\r\n  [\"자\", 1e24],\r\n  [\"해\", 1e20],\r\n  [\"경\", 1e16],\r\n  [\"조\", 1e12],\r\n  [\"억\", 1e8],\r\n  [\"만\", 1e4],\r\n];\r\nconst NATIVE_MAP_ONES: MAP_TYPE = {\r\n  하나: 1,\r\n  둘: 2,\r\n  셋: 3,\r\n  넷: 4,\r\n  다섯: 5,\r\n  여섯: 6,\r\n  일곱: 7,\r\n  여덟: 8,\r\n  아홉: 9,\r\n  한: 1,\r\n  두: 2,\r\n  세: 3,\r\n  석: 3,\r\n  서: 3,\r\n  네: 4,\r\n  넉: 4,\r\n  너: 4,\r\n  닷: 5,\r\n  엿: 6,\r\n};\r\nconst MAP_TENS: MAP_TYPE = {\r\n  열: 10,\r\n  스물: 20,\r\n  서른: 30,\r\n  마흔: 40,\r\n  쉰: 50,\r\n  예순: 60,\r\n  일흔: 70,\r\n  여든: 80,\r\n  아흔: 90,\r\n  십: 10,\r\n  일십: 10,\r\n  이십: 20,\r\n  삼삽: 30,\r\n  사십: 40,\r\n  오십: 50,\r\n  육십: 60,\r\n  륙십: 60,\r\n  칠십: 70,\r\n  팔십: 80,\r\n  구십: 90,\r\n};\r\n\r\nexport {\r\n  MAP_TYPE,\r\n  ORDERED_MAP_TYPE,\r\n  SINO_MAP_ONES,\r\n  SINO_MAP_SMALL,\r\n  SINO_MAP_LARGE,\r\n  NATIVE_MAP_ONES,\r\n  MAP_TENS,\r\n};\r\n","import {\r\n  MAP_TYPE,\r\n  ORDERED_MAP_TYPE,\r\n  SINO_MAP_ONES,\r\n  SINO_MAP_SMALL,\r\n  SINO_MAP_LARGE,\r\n  NATIVE_MAP_ONES,\r\n  MAP_TENS,\r\n} from \"./constants.js\";\r\n\r\nconst isValid = (x: Analysis) => !isNaN(x.parsed);\r\n\r\ntype Analysis = { consumed: string; parsed: number; rest: string };\r\ntype Analyzer = (word: string) => Analysis[];\r\n\r\nfunction unionAnalyzer(...analyzers: Analyzer[]): Analyzer {\r\n  return (word) => analyzers.flatMap((f) => f(word).filter(isValid));\r\n}\r\n\r\nfunction patternAnalyzer(\r\n  pattern: RegExp,\r\n  parser: (x: string) => number\r\n): Analyzer {\r\n  return function (word: string): Analysis[] {\r\n    const match = word.match(pattern);\r\n    if (match == null) return [];\r\n    const matched = match[0];\r\n    const consumed = word.slice(0, matched.length);\r\n    const parsed = parser(matched);\r\n    const rest = word.slice(matched.length);\r\n    return [{ consumed, parsed, rest }];\r\n  };\r\n}\r\n\r\nconst integerAnalyzer = patternAnalyzer(/^[+-]?\\d+(?:,\\d+)*/, (x) =>\r\n  Number(x.replace(/,/g, \"\"))\r\n);\r\nconst decimalAnalyzer = patternAnalyzer(\r\n  /^[+-]?(?:\\d+(?:,\\d+)*[.]\\d*|[.]\\d+)/,\r\n  (x) => Number(x.replace(/,/g, \"\"))\r\n);\r\nconst scientificAnalyzer = patternAnalyzer(\r\n  /^[+-]?(?:\\d+[.]?\\d*|[.]\\d+)e[+-]?\\d+/i,\r\n  Number\r\n);\r\n\r\nfunction tableAnalyzer(table: MAP_TYPE): Analyzer {\r\n  return function (word: string): Analysis[] {\r\n    let analyses = [];\r\n    for (const key in table) {\r\n      if (word.slice(0, key.length) === key) {\r\n        analyses.push({\r\n          consumed: key,\r\n          parsed: table[key],\r\n          rest: word.slice(key.length),\r\n        });\r\n      }\r\n    }\r\n    return analyses;\r\n  };\r\n}\r\n\r\ntype Combiner = (cumulative: Analysis) => (update: Analysis) => Analysis;\r\n\r\nfunction combineByAddition(cumulative: Analysis) {\r\n  return function (update: Analysis): Analysis {\r\n    return {\r\n      consumed: cumulative.consumed + update.consumed,\r\n      parsed: cumulative.parsed + update.parsed,\r\n      rest: update.rest,\r\n    };\r\n  };\r\n}\r\n\r\nfunction combineByMultiplication(cumulative: Analysis) {\r\n  return function (update: Analysis): Analysis {\r\n    return {\r\n      consumed: cumulative.consumed + update.consumed,\r\n      parsed: cumulative.parsed * update.parsed,\r\n      rest: update.rest,\r\n    };\r\n  };\r\n}\r\n\r\nfunction sequentialAnalyzer(\r\n  analyzers: Analyzer[],\r\n  combiner: Combiner = combineByAddition,\r\n  omissible = true\r\n): Analyzer {\r\n  function binary(a: Analyzer, b: Analyzer): Analyzer {\r\n    return function (word: string): Analysis[] {\r\n      let result = [];\r\n      if (omissible) result.push(...b(word));\r\n      for (const analysis of a(word)) {\r\n        if (omissible) result.push(analysis);\r\n        if (analysis.rest.length >= word.length)\r\n          throw Error(\"Infinite Recursion\");\r\n        result.push(...b(analysis.rest).map(combiner(analysis)));\r\n      }\r\n      return result.filter(isValid);\r\n    };\r\n  }\r\n  const empty: Analyzer = (_) => [];\r\n  return analyzers.length ? analyzers.reduce(binary) : empty;\r\n}\r\n\r\nfunction unitAnalyzer(\r\n  getGroup: Analyzer,\r\n  unitName: string,\r\n  unitValue: number\r\n): Analyzer {\r\n  const getUnit = tableAnalyzer({ [unitName]: unitValue });\r\n  return unionAnalyzer(\r\n    getUnit,\r\n    sequentialAnalyzer([getGroup, getUnit], combineByMultiplication, false)\r\n  );\r\n}\r\nfunction groupAnalyzer(\r\n  unitTable: ORDERED_MAP_TYPE,\r\n  getGroup: Analyzer,\r\n  getGroupLast?: Analyzer,\r\n  trim = false\r\n): Analyzer {\r\n  function trimRest(x: Analysis): Analysis {\r\n    const split = x.rest.match(/^(\\s*)(.*)$/);\r\n    if (split == null) return x;\r\n    return {\r\n      consumed: x.consumed + split[1],\r\n      parsed: x.parsed,\r\n      rest: split[2],\r\n    };\r\n  }\r\n  let mappers = unitTable.map((pair) => unitAnalyzer(getGroup, ...pair));\r\n  if (trim) mappers = mappers.map((f) => (x) => f(x).map(trimRest));\r\n  return sequentialAnalyzer([...mappers, getGroupLast || getGroup]);\r\n}\r\n\r\nconst sinoAnalyzerSmall = groupAnalyzer(\r\n  SINO_MAP_SMALL,\r\n  tableAnalyzer(SINO_MAP_ONES)\r\n);\r\nconst sinoAnalyzerLarge = unionAnalyzer(\r\n  patternAnalyzer(/^영/, (_) => 0),\r\n  groupAnalyzer(SINO_MAP_LARGE, sinoAnalyzerSmall, undefined, true)\r\n);\r\nconst sinoAnalyzerFraction = patternAnalyzer(\r\n  /^\\s*점\\s*[영일이삼사오육륙칠팔구]+/,\r\n  function (matched) {\r\n    const sino = matched.trim().slice(1).trim();\r\n    const digits = sino\r\n      .split(\"\")\r\n      .map((x: string) => SINO_MAP_ONES[x] || \"0\")\r\n      .join(\"\");\r\n    return Number(\"0.\" + digits);\r\n  }\r\n);\r\nconst sinoAnalyzer = sequentialAnalyzer([\r\n  sinoAnalyzerLarge,\r\n  sinoAnalyzerFraction,\r\n]);\r\n\r\nconst digitAnalyzer = patternAnalyzer(/^[1-9]/, Number);\r\nconst mixAnalyzerSmall = groupAnalyzer(SINO_MAP_SMALL, digitAnalyzer);\r\nconst mixAnalyzerLarge = groupAnalyzer(\r\n  SINO_MAP_LARGE,\r\n  mixAnalyzerSmall,\r\n  undefined,\r\n  true\r\n);\r\n\r\nconst digitsAnalyzerSmall = patternAnalyzer(/^[1-9]\\d{0,3}/, Number);\r\nconst digitsAnalyzerLarge = groupAnalyzer(\r\n  SINO_MAP_LARGE,\r\n  digitsAnalyzerSmall,\r\n  undefined,\r\n  true\r\n);\r\n\r\nfunction signAnalyzer(f: Analyzer) {\r\n  const plus = sequentialAnalyzer(\r\n    [patternAnalyzer(/^플러스\\s*|^[+](?=\\d)/, (_) => +1), f],\r\n    combineByMultiplication,\r\n    false\r\n  );\r\n  const minus = sequentialAnalyzer(\r\n    [patternAnalyzer(/^마이너스\\s*|^[-](?=\\d)/, (_) => -1), f],\r\n    combineByMultiplication,\r\n    false\r\n  );\r\n  return unionAnalyzer(plus, minus, f);\r\n}\r\n\r\nconst nativeAnalyzerTens = unionAnalyzer(\r\n  patternAnalyzer(/^스무/, (_) => 20),\r\n  sequentialAnalyzer([tableAnalyzer(MAP_TENS), tableAnalyzer(NATIVE_MAP_ONES)])\r\n);\r\nconst nativeAnalyzerSmall = groupAnalyzer(\r\n  [\r\n    [\"천\", 1000],\r\n    [\"백\", 100],\r\n  ],\r\n  tableAnalyzer(SINO_MAP_ONES),\r\n  nativeAnalyzerTens\r\n);\r\nconst nativeAnalyzer = groupAnalyzer(\r\n  SINO_MAP_LARGE,\r\n  sinoAnalyzerSmall,\r\n  nativeAnalyzerSmall,\r\n  true\r\n);\r\n\r\nfunction getBest(...analyses: (Analysis | null)[]): Analysis | null {\r\n  let best: Analysis | null = null;\r\n  for (const analysis of analyses) {\r\n    if (!analysis) continue;\r\n    else if (!best) best = analysis;\r\n    else if (best.rest.length > analysis.rest.length) best = analysis;\r\n  }\r\n  return best;\r\n}\r\n\r\ntype formatType = \"숫자\" | \"숫자혼용\" | \"한자어\" | \"순우리말\";\r\nconst analyzerPool = {\r\n  숫자: unionAnalyzer(integerAnalyzer, decimalAnalyzer, scientificAnalyzer),\r\n  숫자혼용: signAnalyzer(unionAnalyzer(mixAnalyzerLarge, digitsAnalyzerLarge)),\r\n  한자어: signAnalyzer(sinoAnalyzer),\r\n  순우리말: nativeAnalyzer,\r\n};\r\n\r\nfunction extractNumber(\r\n  word: string,\r\n  format: formatType[] = [\"숫자\", \"숫자혼용\", \"한자어\", \"순우리말\"]\r\n): [number, string] {\r\n  word = word.trim();\r\n  const analyzer = unionAnalyzer(\r\n    ...format.map((key) => analyzerPool[key]).filter((x) => x)\r\n  );\r\n  const analyses = analyzer(word);\r\n  const best = getBest(...analyses);\r\n  if (best) return [best.parsed, best.rest.trim()];\r\n  else return [NaN, word];\r\n}\r\n\r\ntype Mapper<T> = (analysis: Analysis) => T | null;\r\nfunction extractAndProcessNumber<T>(\r\n  word: string,\r\n  mapper: Mapper<T>,\r\n  format: formatType[] = [\"숫자\", \"숫자혼용\", \"한자어\", \"순우리말\"],\r\n): T | null {\r\n  word = word.trim();\r\n  const analyzer = unionAnalyzer(\r\n    ...format.map((key) => analyzerPool[key]).filter((x) => x)\r\n  );\r\n  const analyses = analyzer(word);\r\n  const mapped = analyses.map(mapper);\r\n\r\n  let best: number | null = null;\r\n  for (let i = 0; i < analyses.length; i++) {\r\n    if (mapped[i] === null) continue;\r\n    else if (best === null) best = i;\r\n    else if (analyses[best].rest.length > analyses[i].rest.length) best = i;\r\n  }\r\n  return best !== null ? mapped[best] : null;\r\n}\r\n\r\nexport { extractNumber, Analysis, formatType, extractAndProcessNumber, Mapper };\r\n"],"names":["SINO_MAP_ONES","일","이","삼","사","오","육","륙","칠","팔","구","SINO_MAP_SMALL","SINO_MAP_LARGE","isValid","x","isNaN","parsed","unionAnalyzer","word","flatMap","f","filter","patternAnalyzer","pattern","parser","match","matched","consumed","slice","length","rest","integerAnalyzer","Number","replace","decimalAnalyzer","scientificAnalyzer","tableAnalyzer","table","analyses","key","push","combineByAddition","cumulative","update","combineByMultiplication","sequentialAnalyzer","analyzers","combiner","omissible","reduce","a","b","result","analysis","Error","map","_","unitAnalyzer","getGroup","unitName","unitValue","getUnit","groupAnalyzer","unitTable","getGroupLast","trim","trimRest","split","mappers","pair","sinoAnalyzerSmall","sinoAnalyzer","undefined","digits","join","mixAnalyzerSmall","mixAnalyzerLarge","digitsAnalyzerLarge","signAnalyzer","nativeAnalyzerTens","열","스물","서른","마흔","쉰","예순","일흔","여든","아흔","십","일십","이십","삼삽","사십","오십","육십","륙십","칠십","팔십","구십","하나","둘","셋","넷","다섯","여섯","일곱","여덟","아홉","한","두","세","석","서","네","넉","너","닷","엿","nativeAnalyzerSmall","nativeAnalyzer","getBest","best","analyzerPool","숫자","숫자혼용","한자어","순우리말","extractNumber","format","analyzer","NaN","extractAndProcessNumber","mapper","mapped","i"],"mappings":"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"}