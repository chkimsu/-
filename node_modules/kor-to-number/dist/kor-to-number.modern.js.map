{"version":3,"file":"kor-to-number.modern.js","sources":["../src/constants.ts","../src/index.ts"],"sourcesContent":["type MAP_TYPE = {\r\n  [key: string]: number;\r\n};\r\ntype ORDERED_MAP_TYPE = [string, number][];\r\nconst SINO_MAP_ONES: MAP_TYPE = {\r\n  일: 1,\r\n  이: 2,\r\n  삼: 3,\r\n  사: 4,\r\n  오: 5,\r\n  육: 6,\r\n  륙: 6,\r\n  칠: 7,\r\n  팔: 8,\r\n  구: 9,\r\n};\r\nconst SINO_MAP_SMALL: ORDERED_MAP_TYPE = [\r\n  [\"천\", 1000],\r\n  [\"백\", 100],\r\n  [\"십\", 10],\r\n];\r\nconst SINO_MAP_LARGE: ORDERED_MAP_TYPE = [\r\n  [\"양\", 1e28],\r\n  [\"자\", 1e24],\r\n  [\"해\", 1e20],\r\n  [\"경\", 1e16],\r\n  [\"조\", 1e12],\r\n  [\"억\", 1e8],\r\n  [\"만\", 1e4],\r\n];\r\nconst NATIVE_MAP_ONES: MAP_TYPE = {\r\n  하나: 1,\r\n  둘: 2,\r\n  셋: 3,\r\n  넷: 4,\r\n  다섯: 5,\r\n  여섯: 6,\r\n  일곱: 7,\r\n  여덟: 8,\r\n  아홉: 9,\r\n  한: 1,\r\n  두: 2,\r\n  세: 3,\r\n  석: 3,\r\n  서: 3,\r\n  네: 4,\r\n  넉: 4,\r\n  너: 4,\r\n  닷: 5,\r\n  엿: 6,\r\n};\r\nconst MAP_TENS: MAP_TYPE = {\r\n  열: 10,\r\n  스물: 20,\r\n  서른: 30,\r\n  마흔: 40,\r\n  쉰: 50,\r\n  예순: 60,\r\n  일흔: 70,\r\n  여든: 80,\r\n  아흔: 90,\r\n  십: 10,\r\n  일십: 10,\r\n  이십: 20,\r\n  삼삽: 30,\r\n  사십: 40,\r\n  오십: 50,\r\n  육십: 60,\r\n  륙십: 60,\r\n  칠십: 70,\r\n  팔십: 80,\r\n  구십: 90,\r\n};\r\n\r\nexport {\r\n  MAP_TYPE,\r\n  ORDERED_MAP_TYPE,\r\n  SINO_MAP_ONES,\r\n  SINO_MAP_SMALL,\r\n  SINO_MAP_LARGE,\r\n  NATIVE_MAP_ONES,\r\n  MAP_TENS,\r\n};\r\n","import {\r\n  MAP_TYPE,\r\n  ORDERED_MAP_TYPE,\r\n  SINO_MAP_ONES,\r\n  SINO_MAP_SMALL,\r\n  SINO_MAP_LARGE,\r\n  NATIVE_MAP_ONES,\r\n  MAP_TENS,\r\n} from \"./constants.js\";\r\n\r\nconst isValid = (x: Analysis) => !isNaN(x.parsed);\r\n\r\ntype Analysis = { consumed: string; parsed: number; rest: string };\r\ntype Analyzer = (word: string) => Analysis[];\r\n\r\nfunction unionAnalyzer(...analyzers: Analyzer[]): Analyzer {\r\n  return (word) => analyzers.flatMap((f) => f(word).filter(isValid));\r\n}\r\n\r\nfunction patternAnalyzer(\r\n  pattern: RegExp,\r\n  parser: (x: string) => number\r\n): Analyzer {\r\n  return function (word: string): Analysis[] {\r\n    const match = word.match(pattern);\r\n    if (match == null) return [];\r\n    const matched = match[0];\r\n    const consumed = word.slice(0, matched.length);\r\n    const parsed = parser(matched);\r\n    const rest = word.slice(matched.length);\r\n    return [{ consumed, parsed, rest }];\r\n  };\r\n}\r\n\r\nconst integerAnalyzer = patternAnalyzer(/^[+-]?\\d+(?:,\\d+)*/, (x) =>\r\n  Number(x.replace(/,/g, \"\"))\r\n);\r\nconst decimalAnalyzer = patternAnalyzer(\r\n  /^[+-]?(?:\\d+(?:,\\d+)*[.]\\d*|[.]\\d+)/,\r\n  (x) => Number(x.replace(/,/g, \"\"))\r\n);\r\nconst scientificAnalyzer = patternAnalyzer(\r\n  /^[+-]?(?:\\d+[.]?\\d*|[.]\\d+)e[+-]?\\d+/i,\r\n  Number\r\n);\r\n\r\nfunction tableAnalyzer(table: MAP_TYPE): Analyzer {\r\n  return function (word: string): Analysis[] {\r\n    let analyses = [];\r\n    for (const key in table) {\r\n      if (word.slice(0, key.length) === key) {\r\n        analyses.push({\r\n          consumed: key,\r\n          parsed: table[key],\r\n          rest: word.slice(key.length),\r\n        });\r\n      }\r\n    }\r\n    return analyses;\r\n  };\r\n}\r\n\r\ntype Combiner = (cumulative: Analysis) => (update: Analysis) => Analysis;\r\n\r\nfunction combineByAddition(cumulative: Analysis) {\r\n  return function (update: Analysis): Analysis {\r\n    return {\r\n      consumed: cumulative.consumed + update.consumed,\r\n      parsed: cumulative.parsed + update.parsed,\r\n      rest: update.rest,\r\n    };\r\n  };\r\n}\r\n\r\nfunction combineByMultiplication(cumulative: Analysis) {\r\n  return function (update: Analysis): Analysis {\r\n    return {\r\n      consumed: cumulative.consumed + update.consumed,\r\n      parsed: cumulative.parsed * update.parsed,\r\n      rest: update.rest,\r\n    };\r\n  };\r\n}\r\n\r\nfunction sequentialAnalyzer(\r\n  analyzers: Analyzer[],\r\n  combiner: Combiner = combineByAddition,\r\n  omissible = true\r\n): Analyzer {\r\n  function binary(a: Analyzer, b: Analyzer): Analyzer {\r\n    return function (word: string): Analysis[] {\r\n      let result = [];\r\n      if (omissible) result.push(...b(word));\r\n      for (const analysis of a(word)) {\r\n        if (omissible) result.push(analysis);\r\n        if (analysis.rest.length >= word.length)\r\n          throw Error(\"Infinite Recursion\");\r\n        result.push(...b(analysis.rest).map(combiner(analysis)));\r\n      }\r\n      return result.filter(isValid);\r\n    };\r\n  }\r\n  const empty: Analyzer = (_) => [];\r\n  return analyzers.length ? analyzers.reduce(binary) : empty;\r\n}\r\n\r\nfunction unitAnalyzer(\r\n  getGroup: Analyzer,\r\n  unitName: string,\r\n  unitValue: number\r\n): Analyzer {\r\n  const getUnit = tableAnalyzer({ [unitName]: unitValue });\r\n  return unionAnalyzer(\r\n    getUnit,\r\n    sequentialAnalyzer([getGroup, getUnit], combineByMultiplication, false)\r\n  );\r\n}\r\nfunction groupAnalyzer(\r\n  unitTable: ORDERED_MAP_TYPE,\r\n  getGroup: Analyzer,\r\n  getGroupLast?: Analyzer,\r\n  trim = false\r\n): Analyzer {\r\n  function trimRest(x: Analysis): Analysis {\r\n    const split = x.rest.match(/^(\\s*)(.*)$/);\r\n    if (split == null) return x;\r\n    return {\r\n      consumed: x.consumed + split[1],\r\n      parsed: x.parsed,\r\n      rest: split[2],\r\n    };\r\n  }\r\n  let mappers = unitTable.map((pair) => unitAnalyzer(getGroup, ...pair));\r\n  if (trim) mappers = mappers.map((f) => (x) => f(x).map(trimRest));\r\n  return sequentialAnalyzer([...mappers, getGroupLast || getGroup]);\r\n}\r\n\r\nconst sinoAnalyzerSmall = groupAnalyzer(\r\n  SINO_MAP_SMALL,\r\n  tableAnalyzer(SINO_MAP_ONES)\r\n);\r\nconst sinoAnalyzerLarge = unionAnalyzer(\r\n  patternAnalyzer(/^영/, (_) => 0),\r\n  groupAnalyzer(SINO_MAP_LARGE, sinoAnalyzerSmall, undefined, true)\r\n);\r\nconst sinoAnalyzerFraction = patternAnalyzer(\r\n  /^\\s*점\\s*[영일이삼사오육륙칠팔구]+/,\r\n  function (matched) {\r\n    const sino = matched.trim().slice(1).trim();\r\n    const digits = sino\r\n      .split(\"\")\r\n      .map((x: string) => SINO_MAP_ONES[x] || \"0\")\r\n      .join(\"\");\r\n    return Number(\"0.\" + digits);\r\n  }\r\n);\r\nconst sinoAnalyzer = sequentialAnalyzer([\r\n  sinoAnalyzerLarge,\r\n  sinoAnalyzerFraction,\r\n]);\r\n\r\nconst digitAnalyzer = patternAnalyzer(/^[1-9]/, Number);\r\nconst mixAnalyzerSmall = groupAnalyzer(SINO_MAP_SMALL, digitAnalyzer);\r\nconst mixAnalyzerLarge = groupAnalyzer(\r\n  SINO_MAP_LARGE,\r\n  mixAnalyzerSmall,\r\n  undefined,\r\n  true\r\n);\r\n\r\nconst digitsAnalyzerSmall = patternAnalyzer(/^[1-9]\\d{0,3}/, Number);\r\nconst digitsAnalyzerLarge = groupAnalyzer(\r\n  SINO_MAP_LARGE,\r\n  digitsAnalyzerSmall,\r\n  undefined,\r\n  true\r\n);\r\n\r\nfunction signAnalyzer(f: Analyzer) {\r\n  const plus = sequentialAnalyzer(\r\n    [patternAnalyzer(/^플러스\\s*|^[+](?=\\d)/, (_) => +1), f],\r\n    combineByMultiplication,\r\n    false\r\n  );\r\n  const minus = sequentialAnalyzer(\r\n    [patternAnalyzer(/^마이너스\\s*|^[-](?=\\d)/, (_) => -1), f],\r\n    combineByMultiplication,\r\n    false\r\n  );\r\n  return unionAnalyzer(plus, minus, f);\r\n}\r\n\r\nconst nativeAnalyzerTens = unionAnalyzer(\r\n  patternAnalyzer(/^스무/, (_) => 20),\r\n  sequentialAnalyzer([tableAnalyzer(MAP_TENS), tableAnalyzer(NATIVE_MAP_ONES)])\r\n);\r\nconst nativeAnalyzerSmall = groupAnalyzer(\r\n  [\r\n    [\"천\", 1000],\r\n    [\"백\", 100],\r\n  ],\r\n  tableAnalyzer(SINO_MAP_ONES),\r\n  nativeAnalyzerTens\r\n);\r\nconst nativeAnalyzer = groupAnalyzer(\r\n  SINO_MAP_LARGE,\r\n  sinoAnalyzerSmall,\r\n  nativeAnalyzerSmall,\r\n  true\r\n);\r\n\r\nfunction getBest(...analyses: (Analysis | null)[]): Analysis | null {\r\n  let best: Analysis | null = null;\r\n  for (const analysis of analyses) {\r\n    if (!analysis) continue;\r\n    else if (!best) best = analysis;\r\n    else if (best.rest.length > analysis.rest.length) best = analysis;\r\n  }\r\n  return best;\r\n}\r\n\r\ntype formatType = \"숫자\" | \"숫자혼용\" | \"한자어\" | \"순우리말\";\r\nconst analyzerPool = {\r\n  숫자: unionAnalyzer(integerAnalyzer, decimalAnalyzer, scientificAnalyzer),\r\n  숫자혼용: signAnalyzer(unionAnalyzer(mixAnalyzerLarge, digitsAnalyzerLarge)),\r\n  한자어: signAnalyzer(sinoAnalyzer),\r\n  순우리말: nativeAnalyzer,\r\n};\r\n\r\nfunction extractNumber(\r\n  word: string,\r\n  format: formatType[] = [\"숫자\", \"숫자혼용\", \"한자어\", \"순우리말\"]\r\n): [number, string] {\r\n  word = word.trim();\r\n  const analyzer = unionAnalyzer(\r\n    ...format.map((key) => analyzerPool[key]).filter((x) => x)\r\n  );\r\n  const analyses = analyzer(word);\r\n  const best = getBest(...analyses);\r\n  if (best) return [best.parsed, best.rest.trim()];\r\n  else return [NaN, word];\r\n}\r\n\r\ntype Mapper<T> = (analysis: Analysis) => T | null;\r\nfunction extractAndProcessNumber<T>(\r\n  word: string,\r\n  mapper: Mapper<T>,\r\n  format: formatType[] = [\"숫자\", \"숫자혼용\", \"한자어\", \"순우리말\"],\r\n): T | null {\r\n  word = word.trim();\r\n  const analyzer = unionAnalyzer(\r\n    ...format.map((key) => analyzerPool[key]).filter((x) => x)\r\n  );\r\n  const analyses = analyzer(word);\r\n  const mapped = analyses.map(mapper);\r\n\r\n  let best: number | null = null;\r\n  for (let i = 0; i < analyses.length; i++) {\r\n    if (mapped[i] === null) continue;\r\n    else if (best === null) best = i;\r\n    else if (analyses[best].rest.length > analyses[i].rest.length) best = i;\r\n  }\r\n  return best !== null ? mapped[best] : null;\r\n}\r\n\r\nexport { extractNumber, Analysis, formatType, extractAndProcessNumber, Mapper };\r\n"],"names":["SINO_MAP_ONES","일","이","삼","사","오","육","륙","칠","팔","구","SINO_MAP_SMALL","SINO_MAP_LARGE","isValid","x","isNaN","parsed","unionAnalyzer","analyzers","word","flatMap","f","filter","patternAnalyzer","pattern","parser","match","matched","consumed","slice","length","rest","integerAnalyzer","Number","replace","decimalAnalyzer","scientificAnalyzer","tableAnalyzer","table","analyses","key","push","combineByAddition","cumulative","update","combineByMultiplication","sequentialAnalyzer","combiner","omissible","reduce","a","b","result","analysis","Error","map","_","groupAnalyzer","unitTable","getGroup","getGroupLast","trim","trimRest","split","mappers","pair","unitName","unitValue","getUnit","unitAnalyzer","sinoAnalyzerSmall","sinoAnalyzer","undefined","digits","join","mixAnalyzerSmall","mixAnalyzerLarge","digitsAnalyzerLarge","signAnalyzer","nativeAnalyzerTens","열","스물","서른","마흔","쉰","예순","일흔","여든","아흔","십","일십","이십","삼삽","사십","오십","육십","륙십","칠십","팔십","구십","하나","둘","셋","넷","다섯","여섯","일곱","여덟","아홉","한","두","세","석","서","네","넉","너","닷","엿","nativeAnalyzerSmall","nativeAnalyzer","analyzerPool","숫자","숫자혼용","한자어","순우리말","extractNumber","format","best","getBest","analyzer","NaN","extractAndProcessNumber","mapper","mapped","i"],"mappings":"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"}